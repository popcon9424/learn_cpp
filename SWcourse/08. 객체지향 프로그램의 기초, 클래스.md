## 08. 객체지향 프로그램의 기초, 클래스

---

##### 1. 클래스의 상속

1. 클래스 상속의 개요

   - 어떤 클래스의 멤버를 그대로 물려받는 것
   - 기존 정보에 정보를 추가하는 경우, 기존 정보에서 변경된 정보만 수정하여 활용하는 경우 - 개발 비용 절감, 안정성 증가

2. 클래스 상속

   - 기존에 정의된 클래스 멤버(변수, 함수)를 상속받아 새로운 멤버를 추가할 수 있는 기능 - 효율적인 유지 및 보수 가능

   - 기본 클래스 : 상속해주는 클래스 (상위 클래스, 부모 클래스)

   - 파생 클래스 : 상속 받는 클래스 (하위 클래스, 자식 클래그)

   - 파생 클래스 선언 형식

     ```C++
     class 파생클래스명:[접근변경자] 기본클래스명{
         [추가할 멤버 선언;]
     }
     ```

   - 상속에서의 생성자 및 소멸자 호출 순서

     1. 기본 클래스 생성자 : 기본 클래스로부터 상속 받은 멤버의 초기화
     2. 파생 클래스 생성자 : 추가된 멤버변수 초기화
        - 파생 클래스 객체 생성 및 소멸 시 기본 클래스 생성자 및 소멸자의 호출은 가능하나 상속은 불가
     3. 파생 클래스 소멸자
     4. 기본 클래스 소멸자

   - 인자를 필요로 하는 기본 클래스의 생성자 호출

     - 파생 클래스 생성자의 인자 전달 방법

       ```c++
       파생클래스명::파생클래스명(매개변수 목록)
       : 기본클래스명(인자)
       {
           ...
       }
       ```

     - 기본 클래스 생성자의 인자 전달 방법

       ```c++
       기본클래스명::기본클래스명(매개변수목록)
       :멤버변수(매개변수), ...
       {
       }
       ```

       - 기본 클래스 생성자 인자 전달 시 초기화 리스트로 하지 않을 경우 기본 클래스의 디폴트 생성자가 호출
       - 직접 기본 클래스 생성자 호출은 객체의 임시 생성에 불과함

3. 세가지 형태의 상속

   - 접근 변경자를 통한 세가지 형식의 상속
     - 상속에서의 접근 변경자 : private / protected / public
     - 상속 받은 멤버의 접근 수준 변경 가능
   - 접근 변경자에 따른 멤버변수의 접근 수준
     - 기본 클래스의 private 멤버 : 파생 클래스에서의 직접 접근 불가
     - 상속 시 public : 접근 제한을 변경하지 않음
     - 접근 변경자는 public 외에는 거의 사용하지 않음
     - 접근 변경자 생략 시 기본적으로 private으로 간주됨

4. 상속 조건

   - is-a 관계

     - 클래스 간 상속 관계 구성을 위해 파생 클래스로 생성한 객체가 기본 클래스의 한 종류인 관계

       => 파생 클래스로 생성된 객체는 기본 클래스에서 제공하는 모든 멤버를 이용할 수 있기 때문 (반대 관계는 성립하지 않음)

   - has-a 관계

     - 특정 클래스에서 다른 클래스의 멤버를 사용할 수 있는 관계

       => 상속 없이 클래스 안의 한 멤버로 다른 클래스를 포함시켜 이용



##### 2. 상속과 다형성

1. 다형성
   - 객체지향 프로그램의 가장 큰 특징
   - 동일한 명령문을 수행했으나 반응이 다른 것
   - 예시
     - 함수 오버라이드 - 기본 클래스에 있는 멤버함수와 동일한 이름의 함수를 파생 클래스에서 다시 정의한 것
       시그니처(함수명, 매개변수 개수, 자료형 등)가 동일해야 함수 재정의 가능, 다를 경우 함수 오버로딩 발생
2. 가상함수
   - 정적 바인딩과 동적 바인딩
     - 정적 바인딩(static binding)
       - C++ 컴파일러가 소스코드 컴파일 시 모든 함수의 시작주소를 미리 결정하는 것
       - 객체 생성 시 멤버변수에 대한 메모리 할당과 함께 시작 주소 설정
     - 동적 바인딩(dynamic binding)
       - 실행 시 함수 오버로드(재정의)를 위해 함수를 가상함수로 지정할 때 함수의 주소가 설정되는 방식
       - 가상함수로 지정할 경우 컴파일러 실행시 주소를 계산해야 할 함수로 인식함
   - 가상함수로 지정하는 방법 : 기본 클래스의 해당함수 정의 시 'virtual' 지정자 삽입 (파생 클래스로 상속, 명시적 관례)
   - 소멸자
     - 함수 재정의를 위한 가상함수 정의 시 소멸자 함수도 함께 가상함수로 등록
3. 가상함수와 참조 사용
   - 가상함수를 이용한 함수 재정의
     - 포인터 및 레퍼런스에 그대로 적용
       - 기본 클래스 레퍼런스로 대입
       - 함수 호출 시 매개변수에서 인자를 전달받음



##### 3. 추상 클래스

1. 순수 가상함수(Pure Virtual Function)

   - 정의 없이 선언만 있는 가상함수

   - 미리 호출 계획을 세우기 위해 만드는 함수

     ```c++
     virtual 멤버함수명() = 0;
     ```

2. 추상 클래스의 사용(Abstract class)

   - 순수 가상함수를 포함하고 있는 클래스
   - 함수 정의 부분이 없으므로 객체의 직접 생성은 불가, 포인터 선언은 가능
   - 포인터를 이용한 함수 재정의(다형성 구축) 가능
   - 추상 클래스 작성 목적 및 유의사항
     - 작성 목적
       - 파생 클래스 동작 형석의 사전 설계를 위한 기본 클래스로 사용 가능
         - 추상 클래스 : 순수 가상함수를 통한 객체에 접근 가능한 인터페이스 제공
         - 파생 클래스 : 추상 클래스의 인터페이스 구현 방법으로 사용
     - 주의사항
       - 순수 가상 함수는 사용 전 반드시 재정의되어 있어야 함
         - 재정의하지 않아 파생 클래스가 추상 클래스가 될 경우 파생 클래스 객체도 생성 불가



##### 4. 다중 상속

1. 다중 상속의 이해

   - 동시에 여러 기본 클래스로부터 상속 받아 파생 클래스 생성

     ```c++
     class 파생클래스명: 접근변경자 기본클래스명1, 접근변경자 기본클래스명2, ...
     {
         [명령문;]
     }
     ```

     - 여러 기반 클래스에 같은 이름의 멤버가 있는 경우 멤버 이름 사용시 클래스 이름 및 범위 지정자(::)를 함께 기술하여 어느 클래스에서 상속 받은 멤버인지를 명확히 지정

